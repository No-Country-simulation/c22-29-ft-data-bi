---
jupyter: python3
lang: "es"
execute:
  echo: false
  output: false
---

```{python}
import numpy as np
import pandas as pd
import os
import seaborn as sns
import matplotlib.pyplot as plt
```
```{python}
import pyprojroot


root_path = pyprojroot.here()

data_path = root_path / 'data' / 'raw'

beg_inv = pd.read_csv(data_path.joinpath('BegInvFINAL12312016.csv'))
end_inv = pd.read_csv(data_path.joinpath('EndInvFINAL12312016.csv'))
sales = pd.read_csv(data_path.joinpath('SalesFINAL12312016.csv'))
purchases = pd.read_csv(data_path.joinpath('PurchasesFINAL12312016.csv'))
invoice_purchases = pd.read_csv(
    data_path.joinpath('InvoicePurchases12312016.csv'))
purchase_prices = pd.read_csv(data_path.joinpath('2017PurchasePricesDec.csv'))
```

```{python}
# Ver las dimensiones del dataset

print("Dimensiones de cada archivo:")
print("Inventario Inicial:", beg_inv.shape)
print("Inventario Final:", end_inv.shape)
print("Compras:", purchases.shape)
print("Facturas de Compras:", invoice_purchases.shape)
print("Precios de compras:", invoice_purchases.shape)
print("Ventas:", sales.shape)
```

```{python}
print("purchase_prices Columns:")
print(purchase_prices.columns.tolist())

print("\nbeg_inv Columns:")
print(beg_inv.columns.tolist())

print("\nend_inv Columns:")
print(end_inv.columns.tolist())

print("\ninvoice_purchases Columns:")
print(invoice_purchases.columns.tolist())

print("\npurchases Columns:")
print(purchases.columns.tolist())

print("\nsales Columns:")
print(sales.columns.tolist())
```

```{python}
# Mostrar nombres de columnas y una vista previa de cada conjunto de datos para identificar inconsistencias
print("Columnas y primeras filas de cada archivo:")

print("Inventario Inicial:")
print(beg_inv.head(10))
print('beg_inv info: ')
print(beg_inv.info())
print('beg_inv null values: ')
print(beg_inv.isnull().sum())
print('beg_inv duplicated: ')
print(beg_inv.duplicated().value_counts())

print("\nInventario Final:")
print(end_inv.head(10))
print('end_inv info: ')
print(end_inv.info())
print('end_inv null values: ')
print(end_inv.isnull().sum())
print('end_inv duplicated: ')
print(end_inv.duplicated().value_counts())

print("\nCompras:")
print(purchases.head(10))
print('purchases info: ')
print(purchases.info())
print('purchases null values: ')
print(purchases.isnull().sum())
print('purchases duplicated: ')
print(purchases.duplicated().value_counts())

print("\nFacturas de Compras:")
print(invoice_purchases.head(10))
print('invoice_purchases info: ')
print(invoice_purchases.info())
print('invoice_purchases null values: ')
print(invoice_purchases.isnull().sum())
print('invoice_purchases duplicated: ')
print(invoice_purchases.duplicated().value_counts())

print("\nPrecio de compras:")
print(purchase_prices.head(10))
print('purchase_prices info: ')
print(purchase_prices.info())
print('purchase_prices null values: ')
print(purchase_prices.isnull().sum())
print('purchase_prices duplicated: ')
print(purchase_prices.duplicated().value_counts())

print("\nVentas:")
print(sales.head(10))
print('sales info: ')
print(sales.info())
print('sales null values: ')
print(sales.isnull().sum())
print('sales duplicated: ')
print(sales.duplicated().value_counts())
```

# üöÄOptimizacion del control de inventario para BottleFlow Logistics
> Un enfoque estrat√©gico basado en datos #Supply ChainüöÄ

## Descripci√≥n de la empresa
BotterFlow Logistic es una distribuidora de bebidas alcoh√≥licas que opera a nivel nacional en Estados Unidos. Nuestro objetivo es optimizar la gesti√≥n del inventario para abordar los desaf√≠os que afectan nuestra eficiencia operativa.
La empresa cuenta con una red log√≠stica robusta que le permite abastecer a supermercados, restaurantes, bares y tiendas especializadas en todo el pa√≠s. Su cat√°logo incluye marcas nacionales e internacionales de renombre, lo que asegura vari
variedad y calidad para satisfacer las necesidades de sus clientes.

## Objetivos
- Gestionar los niveles de inventario de manera eficaz en todas las categor√≠as.
- Optimizar los costos asociados al almacenamiento y la distribuci√≥n de productos.
- Integrar datos hist√≥ricos y en tiempo real para decisiones m√°s precisas.

## Impacto
- Aumento de la rentabilidad al evitar p√©rdidas relacionadas con la falta o el exceso de stock.
- Mayor competitividad en el mercado al responder m√°s eficientemente a las demandas del cliente, impulsando as√≠ las ventas.
- Implementaci√≥n de sistemas de previsi√≥n de demanda m√°s precisos para ajustar los niveles de inventario a las necesidades reales.

## Tecnolog√≠as utilizadas
- Python
- Power BI
- SQL

## Desaf√≠os superados
- Almacenamiento y consulta eficiente de grandes vol√∫menes de datos.
- Dise√±o de bases de datos y optimizaci√≥n de consultas para mejorar el rendimiento.
- Desarrollo de modelos de predicci√≥n y an√°lisis de datos avanzados.
- Automatizaci√≥n de tareas relacionadas con la limpieza, transformaci√≥n y carga de datos desde excel, csv a SQL

## Problema
La empresa "BotterFlow Logistic" se especializa en la comercializaci√≥n de licores. Actualmente, enfrenta problemas en el manejo de su stock debido a inconsistencias entre las cantidades registradas en su sistema y el inventario real en sus bodegas. Lo cual ha generado incumplimiento en pedidos; clientes mayoristas han solicitado productos que, seg√∫n el sistema, est√°n disponibles, pero al momento de preparar los pedidos se descubre que no hay suficiente stock. Otros productos permanecen en inventario m√°s tiempo del esperado, aumentando costos de almacenamiento y el riesgo de expiraci√≥n. Realizaci√≥n de pedidos innecesarios a proveedores o insuficientes para cubrir la demanda, afectando la rotaci√≥n de productos.
El equipo de gesti√≥n realiza un an√°lisis de inventario para identificar √°reas de mejora y optimizar sus pr√°cticas de gesti√≥n de inventario.

## Problemas identificados

- **Sobrestock:** Exceso de inventario que genera costos innecesarios.  
- **Stock vac√≠o:** Carencia de productos que limita la capacidad de satisfacer la demanda de los clientes.  
- **Incongruencia de los datos:** Falta e inconsistencia de los datos y adaptacion a herramientas para mayores volumenes de datos


```{python}
"""### De la exploraci√≥n de los datos podemos observar:
- Tanto inventario inicial como inventario final presentan las misma columnas.
- Podemos observar que algunas tablas presentan valores faltantes.
- El formato de fecha es diferente entre las tablas. La tabla "sales" tiene un formato m/d/yyyy, minetras las otras tablas presentan un formato yyyy/mm/dd
- Se presentan inconsistencias en la columna "Size" de todas las tablas, ya que se utilizan diferentes unidades de medici√≥n. Por ejemplo, algunas tablas presentan un formato 750 mL, en otras Liter, en otras 1.75L, 375mL 2 Pk. Por tanto, es necesario unificar la unidad de medida.
- No hay valores duplicados.
"""
```

```{python}
"""Manejo de valores faltantes:
En el inventario final la columna "City" presenta 1284 valores faltantes de 224489 entradas. Si comparamos las columnas "InventoryId" de las tablas de inventario inicial y final, podemos ver que los valores faltantes de la columna "City" del inventario final, se correponden con la tienda 46.
Esta tienda se indica como 46_TYWARDREATH en la columna "InventoryId" presente en la tabla de inventario inicail. Por lo tanto, podemos rellenar los valores faltantes de las filas de la columna "City" con el nombre TYWARDREATH. En la tabla compras, solo se presentan 3 vlaores faltantes en la columna "Size". Podemos eliminar estas filas o rellenarlas.
En la tabla facturas de compra, se presentan 5169 valores faltantes de 5543 entradas. Son demasiados datos faltantes, por lo tanto podemos desestimar la columna y eliminarla.
En la tabla precio de compra, solo hay 1 valor faltante en cada una de las columnas "Description", "Size" y "Volume". Podemos eliminar las filas con los datos faltantes. Adem√°s, la comlumna "Volume" indica lo mismo que la columna "Size" por lo que ser√≠a de utilidad eliminar dicha columna. Tambi√©n se elimina la columna "Volume" de la tabla ventas."""
```

```{python}
# Manejo de datos faltantes
```

```{python}
# Realizar copia del dataset
beg_inv_f = beg_inv.copy() 
end_inv_f = end_inv.copy()
purchases_f = purchases.copy()
invoice_purchases_f= invoice_purchases.copy()
purchase_prices_f = purchase_prices.copy()
sales_f = sales.copy()
```

```{python}
# Rellenar datos faltantes en la columna "City" del inventario final
end_inv_f["City"] = end_inv_f["City"].fillna("TYWARDREATH")

# Eliminar filas con valores faltantes en "Size" en la tabla compras
purchases_f.dropna(subset=["Size"], inplace=True)

# Eliminar columna "Approval" de la tabla facturas de compra
invoice_purchases_f = invoice_purchases_f.drop(['Approval'], axis=1)

# Eliminar valores faltantes de las columnas "Description" y "Size" de la tabla precios de compra
purchase_prices_f.dropna(subset=["Description"], inplace=True)
purchase_prices_f.dropna(subset=["Size"], inplace=True)

# Eliminar columna "Volume" de la tabla precios de compra
purchase_prices_f = purchase_prices_f.drop(["Volume"], axis=1)
sales_f = sales_f.drop(["Volume"], axis = 1)
```

```{python}
print('beg_inv_f columns:')
print(beg_inv_f.columns)
print('beg_inv_f null values: ')
print(beg_inv_f.isnull().sum().value_counts())

print('end_inv_f columns:')
print(end_inv_f.columns)
print('end_inv_f null values: ')
print(end_inv_f.isnull().sum().value_counts())

print('purchases_f columns:')
print(purchases_f.columns)
print('purchases_f null values: ')
print(purchases_f.isnull().sum().value_counts())

print('invoice_purchases_f columns:')
print(invoice_purchases_f.columns)
print('invoice_purchases_f null values: ')
print(invoice_purchases_f.isnull().sum().value_counts())

print('purchase_prices_f columns:')
print(purchase_prices_f.columns)
print('purchase_prices_f null values: ')
print(purchase_prices_f.isnull().sum().value_counts())

print('sales_f columns:')
print(sales_f.columns)
print('sales_f null values: ')
print(sales_f.isnull().sum().value_counts())
```

```{python}
# Estandarizar el formato de fecha
def format_time(df, *columns, date_format='%Y-%m-%d'):
    for col in columns:
        try:
            df[col] = pd.to_datetime(df[col], errors='coerce')  # Convierte a datetime
            df[col] = df[col].dt.strftime(date_format)          # Aplica formato
        except Exception as e:
            print(f"Error al procesar la columna {col}: {e}")
    return df


beg_inv_f = format_time(beg_inv_f, "startDate")
end_inv_f = format_time(end_inv_f, "endDate")
purchases_f = format_time(purchases_f, "PODate", "ReceivingDate", "InvoiceDate", "PayDate")
invoice_purchases_f = format_time(invoice_purchases_f, "InvoiceDate", "PODate", "PayDate")
sales_f = format_time(sales_f, "SalesDate")
```

```{python}
# Eliminar espacios en todas las columnas tipo texto.
def strip_spaces(df):
    for col in df.select_dtypes(include=['object', 'string']).columns:
        df[col] = df[col].str.strip()
    return df

# Aplicar la funci√≥n a cada archivo
beg_inv_f = strip_spaces(beg_inv_f)
end_inv_f = strip_spaces(end_inv_f)
purchases_f = strip_spaces(purchases_f)
invoice_purchases_f = strip_spaces(invoice_purchases_f)
sales_f = strip_spaces(sales_f)

# Confirmar que se eliminaron los espacios
print(beg_inv_f.head())
print(end_inv_f.head())
print(purchases_f.head())
print(invoice_purchases_f.head())
print(sales_f.head())
```

```{python}
# Combinar las columnas "Size" de los DataFrames, ignorando las ausentes
data_frames = [beg_inv_f, end_inv_f, purchases_f, purchase_prices_f, sales_f]
all_sizes = pd.concat([df["Size"] for df in data_frames if "Size" in df.columns], ignore_index=True)

# Contar las ocurrencias √∫nicas directamente con value_counts
size_counts = all_sizes.value_counts().reset_index()
size_counts.columns = ["Size", "Total Count"]

pd.set_option('display.max_rows', None)

# Mostrar el resultado
print(size_counts)

pd.reset_option('display.max_rows')
```
```{python}
"""
Encontramos 76 diferentes tipos de medidas para expresar el volumen.
Se observan diferentes expresiones de medidas de volumen.  
- Para referenciar litro encontramos referencias como: Liter, L o l.  
- Se observan vol√∫menes expresados en Oz.  
- Hay otros patrones como 750mL, 375mL 2 Pk, 25.0, etc.  
__Debemos estandarizar la medida de volume__
"""
```
```{python}
import re

# Funci√≥n para estandarizar las medidas de volumen en mililitros (mL)
def convert_to_milliliters(size):
    size = str(size).lower()
    
    # Manejo del caso "3/100ml" y "5/2 oz"
    if "3/100ml" in size: 
        return 3 * 100  # 3/100ml ‚Üí 3 paquetes de 100ml
    elif '5/2 oz' in size: 
        return round(10 * 29.5735, 2)  # 5/2 oz ‚Üí 10 onzas (1/2 * 5)

    # Convertir galones a mililitros
    elif 'gal' in size:
        gal_value = float(re.search(r'\d+\.*\d*', size).group())
        return round(gal_value * 3785.41, 2)  # 1 gal = 3785.41 mL

    # Manejar patrones como "750ml", "750mL + 3/", "750 4pk", etc.
    elif 'ml' in size:
        if 'p' in size:
            ml_value, pack_value = re.search(r'(\d+\.*\d*)\s*m*l*\s*(\d*)\s*p*/*P*k*/*', size).groups()
            ml_value = float(ml_value)
            pack_value = float(pack_value) if pack_value else 1
            return round(ml_value * pack_value, 2)  # Multiplicar por el n√∫mero de paquetes
        elif '+' in size:
            ml_value, pack_value = map(float, re.findall(r'\d+\.*\d*', size))
            return round(ml_value + (pack_value * 50), 2)  # Sumar la cantidad adicional
        else:
            ml_value = float(re.search(r'\d+\.*\d*', size).group())
            return round(ml_value, 2)

    # Convertir litros a mililitros
    elif 'liter' in size or 'l' in size:
        if size == 'liter' or size == 'l': 
            return 1000.0
        else:
            liter_value = float(re.search(r'\d+\.*\d*', size).group())
            return round(liter_value * 1000, 2)  # 1 litro = 1000 mL

    # Convertir onzas l√≠quidas (oz) a mililitros
    elif 'oz' in size:
        oz_value = float(re.search(r'\d+\.*\d*', size).group())
        return round(oz_value * 29.5735, 2)  # 1 oz = 29.5735 mL

    # Retornar None si no se puede interpretar
    else:
        return None

# Lista de DataFrames
datasets = [beg_inv_f, end_inv_f, purchases_f, purchase_prices_f, sales_f]

# Aplicar la funci√≥n de conversi√≥n a cada DataFrame
for i, dataset in enumerate(datasets):
    if "Size" in dataset.columns:  # Verificar si la columna "Size" existe
        dataset['Size'] = dataset['Size'].apply(convert_to_milliliters)
        datasets[i] = dataset

# Imprimir los resultados convertidos
for i, dataset in enumerate(datasets):
    print(f"DataFrame {i + 1}:")
    print(dataset)
    print()
```

## An√°lisis de inventario
En esta secci√≥n, analizaremos los par√°metros fundamentales de la gesti√≥n de inventario y extraeremos informaci√≥n relevante sobre stock e inventario disponible.

Se buscar√°:

1. Detectar y analizar outliers.

2. Visualizar la informaci√≥n de manera m√°s clara.

3. Agregar contexto relevante (proveedor, riesgo).

```{python}
purchases_f['ReceivingDate'] = pd.to_datetime(purchases_f['ReceivingDate'], format='%Y-%m-%d', errors='coerce')
purchases_f['PODate'] = pd.to_datetime(purchases_f['PODate'], format='%Y-%m-%d', errors='coerce')

# Calcular el plazo de entrega en d√≠as
purchases_f['Lead_Time'] = (purchases_f['ReceivingDate'] - purchases_f['PODate']).dt.days

# Agrupaci√≥n adicional por proveedor
LT_summary = purchases_f.groupby(['Brand', 'Description']).agg(
    Max_LT_inDays=('Lead_Time', 'max'), 
    Min_LT_inDays=('Lead_Time', 'min'), 
    Avg_LT_inDays=('Lead_Time', 'mean')).round(2).reset_index()

# Identificar outliers en Lead_Time usando IQR
q1 = purchases_f['Lead_Time'].quantile(0.25)
q3 = purchases_f['Lead_Time'].quantile(0.75)
iqr = q3 - q1
outlier_threshold_low = q1 - 1.5 * iqr
outlier_threshold_high = q3 + 1.5 * iqr

# Filtrar outliers
outliers = purchases_f[(purchases_f['Lead_Time'] < outlier_threshold_low) | 
                       (purchases_f['Lead_Time'] > outlier_threshold_high)]
print(f"N√∫mero de outliers detectados: {len(outliers)}")
```

```{python}
# |  output: true
# Boxplot para tiempos de entrega
plt.figure(figsize=(10, 6))
sns.boxplot(data=LT_summary, x="Avg_LT_inDays", color="skyblue")
plt.title("Boxplot del Tiempo Promedio de Entrega")
plt.xlabel("Tiempo Promedio de Entrega (D√≠as)")
plt.show()
```

El gr√°fico de caja muestra la distribuci√≥n de los plazos de entrega promedio de los productos. 
La mayor√≠a de los productos tienen un plazo de entrega promedio de aproximadamente 7 u 8 d√≠as, como lo muestra la distribuci√≥n normal. Por lo tanto, la mayor√≠a de los vendedores entregan los productos en el plazo de una semana.


```{python}
# Clasificar productos seg√∫n tiempo m√°ximo de entrega
def categorize_lead_time(max_lt):
    if max_lt <= 5:
        return "Riesgo Bajo"
    elif 5 < max_lt <= 15:
        return "Riesgo Medio"
    else:
        return "Riesgo Alto"

LT_summary['Riesgo'] = LT_summary['Max_LT_inDays'].apply(categorize_lead_time)

# Ver distribuci√≥n de categor√≠as de riesgo
risk_distribution = LT_summary['Riesgo'].value_counts()
print(risk_distribution)
```
```{python}
# |  output: true
# Gr√°fico de barras para distribuci√≥n de riesgo
risk_distribution.plot(
    kind='bar', color=['green', 'orange', 'red'], alpha=0.7, rot=0)
plt.title("Distribuci√≥n de Categor√≠as de Riesgo")
plt.xlabel("Categor√≠a de Riesgo")
plt.ylabel("Cantidad de Productos")
plt.show()
```

```{python}
# |  output: true
# Calcular desviaci√≥n est√°ndar del tiempo de entrega
LT_summary['Std_LT_inDays'] = purchases_f.groupby(['Brand', 'Description'])['Lead_Time'].std().round(2).reset_index(drop=True)

# Calcular proporci√≥n de pedidos entregados en menos de X d√≠as (por ejemplo, 7 d√≠as)
LT_summary['On_Time_Rate'] = purchases_f.groupby(['Brand', 'Description']).apply(
    lambda group: (group['Lead_Time'] <= 7).mean(), include_groups=False
).round(2).reset_index(drop=True)

# Histograma de desviaci√≥n est√°ndar del tiempo de entrega
plt.figure(figsize=(10, 6))
plt.hist(LT_summary['Std_LT_inDays'], bins=30, color='skyblue', edgecolor='black', alpha=0.7)
plt.title("Distribuci√≥n de la Desviaci√≥n Est√°ndar del Tiempo de Entrega")
plt.xlabel("Desviaci√≥n Est√°ndar (D√≠as)")
plt.ylabel("Frecuencia")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()
```

### Stock de seguridad e inventario disponible

Como el stock de seguridad mide la cantidad de inventario de reserva que se debe tener, se debe determinar el stock de seguridad √≥ptimo en funci√≥n de la cantidad de ventas y la cantidad de stock de seguridad necesaria para que las ventas se realicen sin problemas.


```{python}
# Convertir SalesDate a formato datetime
sales_f['SalesDate'] = pd.to_datetime(sales_f['SalesDate'], errors='coerce')

# Realizar el resumen de ventas
sales_f_summary = sales_f.groupby(['Brand', 'Description']).agg(
                        Max_Sales_Qty=("SalesQuantity", 'max'),
                        Min_Sales_Qty=("SalesQuantity", 'min'),
                        Tot_SalesQty=('SalesQuantity', 'sum')).reset_index()

# Calcular las ventas por d√≠a de cada producto agrupado por marca
total_sales_days = (sales_f['SalesDate'].max() - sales_f['SalesDate'].min()).days
sales_f_summary['Avg_Sales/Day'] = (sales_f_summary['Tot_SalesQty'] / total_sales_days).round(2)

# Unir el tiempo de entrega y los datos de ventas
Safty_stock = pd.merge(sales_f_summary, LT_summary, on = ["Brand", "Description"])

# Calcular el stock de seguridad √≥ptimo y stock m√°ximo necesario
Safty_stock["Optimal_SS"] = np.ceil(Safty_stock["Avg_LT_inDays"] * Safty_stock["Avg_Sales/Day"]).round(0)
Safty_stock["Max_SS"] = np.ceil(Safty_stock["Max_LT_inDays"] * Safty_stock["Avg_Sales/Day"]).round(0)

# Identificar outliers en las ventas
q1 = sales_f_summary['Avg_Sales/Day'].quantile(0.25)
q3 = sales_f_summary['Avg_Sales/Day'].quantile(0.75)
iqr = q3 - q1
outlier_threshold_low = q1 - 1.5 * iqr
outlier_threshold_high = q3 + 1.5 * iqr

# Filtrar productos sin outliers
filtered_data = sales_f_summary[
    (sales_f_summary['Avg_Sales/Day'] >= outlier_threshold_low) &
    (sales_f_summary['Avg_Sales/Day'] <= outlier_threshold_high)
]

# Verificar los resultados
print(sales_f_summary.head())
```

```{python}
# |  output: true
# Histograma de ventas promedio por d√≠a
plt.figure(figsize=(10, 6))
plt.hist(sales_f_summary['Avg_Sales/Day'], bins=30, color='steelblue', edgecolor='black', alpha=0.7)
plt.title("Distribuci√≥n de Ventas Promedio por D√≠a")
plt.xlabel("Ventas Promedio por D√≠a")
plt.ylabel("Frecuencia")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Histograma de distribuci√≥n √≥ptima del stock seguro
plt.figure(figsize=(10, 6))
plt.hist(Safty_stock['Optimal_SS'], bins=30, color='tomato', edgecolor='black', alpha=0.7)
plt.title("Distribuci√≥n de stock de seguridad")
plt.xlabel("Stock seguro √≥ptimo")
plt.ylabel("Frecuencia")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()
```

Los histogramas representan el recuento de stock de seguridad requerido para cada marca junto con sus ventas diarias promedio. Sin embargo, debido a que los datos est√°n muy sesgados hacia la izquierda, la distribuci√≥n de los puntos de datos en el lado derecho no es claramente visible.
Para poder visualizar esto mejor, utilizaremos un diagrama de caja.

```{python}
# |  output: true
fig, ax = plt.subplots(figsize=(15, 3))
ax.boxplot(Safty_stock['Optimal_SS'], vert=False, boxprops=dict(color='tab:orange'),  
                            flierprops=dict(markeredgecolor='tab:gray'))
ax.set_xticks(range(0, int(Safty_stock["Optimal_SS"].max()) + 1, 200)) 
ax.set_title('Distribuci√≥n √≥ptima del stock seguro')
ax.set_xlabel('Stock Seguro √ìptimo')
ax.set_ylabel('Distribuci√≥n')
plt.show()
```

Como podemos observar, la mayor√≠a de los productos requieren un stock de seguridad de entre cero y 200. 
Sin embargo, el diagrama de caja muestra que algunos productos necesitan hasta 3500 unidades en existencias de seguridad.

Evaluar el inventario disponible.
Se tendra en cuenta el inventario final, como inventario disponible.

```{python}
# Analisis de inventario final disponible por marca
# Filtrar inventario m√°s reciente
latest_onhand_inv = end_inv_f[end_inv_f['endDate'] == end_inv_f['endDate'].max()] \
                    .groupby(['Brand', 'Description']).agg(Onhand_Stock=('onHand', 'sum')).reset_index()

# Uni√≥n con Safty_stock
onhand_inv_data = Safty_stock.merge(latest_onhand_inv, on=['Brand', 'Description'], how='left').fillna({'Onhand_Stock': 0})

# Calcular estado del inventario
onhand_inv_data['Inventory_Status'] = onhand_inv_data['Onhand_Stock'] - onhand_inv_data['Optimal_SS']
onhand_inv_data['Inv_Shortage/Surplus'] = np.where(
    onhand_inv_data['Inventory_Status'] < 0, 'Inv_Shortage',
    np.where(onhand_inv_data['Inventory_Status'] == 0, 'Balance', 'Inv_Surplus')
)

# Resumen de categor√≠as
print(onhand_inv_data['Inv_Shortage/Surplus'].value_counts())
```

```{python}
# |  output: true
# Visualizaci√≥n de estados del inventario
fig, ax = plt.subplots(figsize=(11, 4))
sns.boxplot(data=onhand_inv_data, x="Inv_Shortage/Surplus", y="Inventory_Status", ax=ax, palette="Set2")

# Agregar conteos en el gr√°fico
counts = onhand_inv_data['Inv_Shortage/Surplus'].value_counts()
for i, count in enumerate(counts):
    ax.text(i, onhand_inv_data['Inventory_Status'].max(), str(count), ha='center', va='bottom', fontsize=10)

# Etiquetas y t√≠tulo
plt.xlabel("Estado del Inventario")
plt.ylabel("Estado (Diferencia)")
plt.title("Distribuci√≥n del Estado del Inventario")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()
```

El gr√°fico muestra que la empresa tiene un inventario excesivo de un 84% de sus productos, lo que le genera
costos de mantenimiento de inventario sustanciales. Por otro lado, hay un 15% de d√©ficit en el inventario.
De hecho, solo un 1% del inventario presenta un stock equilibrado.

La empresa debe abordar este problema reduciendo el excedente de inventario y cubriendo los faltantes de inventario para mantener el equilibrio.


```{python}
# Analizar cuales son los mejores y peores productos al comienzo y al final del a√±o

# Agrupar por marca y descripci√≥n y resumir el inventario de principios de a√±o
beg_summary = beg_inv.groupby(['Brand', 'Description'])['onHand'].sum().reset_index().sort_values(by='onHand', ascending=False)

# Agrupar por marca y descripci√≥n y resumir el inventario de final de a√±o
end_summary = end_inv.groupby(['Brand', 'Description'])['onHand'].sum().reset_index().sort_values(by='onHand', ascending=False)

# Identificar los 5 mejores productos al principio y al final del a√±o
top_5_beg = beg_summary.iloc[:5]
top_5_end = end_summary.iloc[:5]

# Identificar los 5 productos con peores resultados al principio y al final del a√±o
bottom_5_beg = beg_summary.iloc[-5:]
bottom_5_end = end_summary.iloc[-5:]

print("Top 5 productos al comienzo de a√±o:\n", top_5_beg)
print("\nTop 5 productos al final del a√±o:\n", top_5_end)
print("\nPeores 5 productos al principio del a√±o:\n", bottom_5_beg)
print("\nPeores 5 productos al final del a√±o:\n", bottom_5_end)
```

```{python}
# Si graficamos esto:

# Validar que los datos existan para cada subconjunto
if not top_5_beg.empty:
    fig, axes = plt.subplots(2, 2, figsize=(14, 10), gridspec_kw={'hspace': 0.4, 'wspace': 0.4})

    # Top 5 productos al comienzo del a√±o
    sns.barplot(ax=axes[0, 0], x=top_5_beg['onHand'], y=top_5_beg['Description'], hue=top_5_beg['Description'], 
                palette="viridis", dodge=False, legend=False)
    axes[0, 0].set_title("Top 5 Productos - Comienzo del A√±o")
    axes[0, 0].set_xlabel("Inventario (unidades)")
    axes[0, 0].set_ylabel("Productos")

    # Top 5 productos al final del a√±o
    sns.barplot(ax=axes[0, 1], x=top_5_end['onHand'], y=top_5_end['Description'], hue=top_5_end['Description'], 
                palette="magma", dodge=False, legend=False)
    axes[0, 1].set_title("Top 5 Productos - Final del A√±o")
    axes[0, 1].set_xlabel("Inventario (unidades)")
    axes[0, 1].set_ylabel("Productos")

    # Validar si existen datos para los peores productos al inicio del a√±o
    if not bottom_5_beg.empty:
        sns.barplot(ax=axes[1, 0], x=bottom_5_beg['onHand'], y=bottom_5_beg['Description'], hue=bottom_5_beg['Description'], 
                    palette="cool", dodge=False, legend=False)
        axes[1, 0].set_title("Peores 5 Productos - Comienzo del A√±o")
        axes[1, 0].set_xlabel("Inventario (unidades)")
        axes[1, 0].set_ylabel("Productos")
    else:
        axes[1, 0].text(0.5, 0.5, "Sin datos", fontsize=14, ha='center', va='center')
        axes[1, 0].set_title("Peores 5 Productos - Comienzo del A√±o")

    # Validar si existen datos para los peores productos al final del a√±o
    if not bottom_5_end.empty:
        sns.barplot(ax=axes[1, 1], x=bottom_5_end['onHand'], y=bottom_5_end['Description'], hue=bottom_5_end['Description'], 
                    palette="autumn", dodge=False, legend=False)
        axes[1, 1].set_title("Peores 5 Productos - Final del A√±o")
        axes[1, 1].set_xlabel("Inventario (unidades)")
        axes[1, 1].set_ylabel("Productos")
    else:
        axes[1, 1].text(0.5, 0.5, "Sin datos", fontsize=14, ha='center', va='center')
        axes[1, 1].set_title("Peores 5 Productos - Final del A√±o")

    # T√≠tulo global
    plt.suptitle("Comparaci√≥n de Inventarios - Principio vs. Final del A√±o", fontsize=16, weight='bold', color='tomato')
    plt.show()
else:
    print("No hay datos suficientes para realizar los gr√°ficos.")

"""
Se puede observa que los √∫ltimos 2 gr√°ficos est√°n vac√≠os, esto se debe a que no hay existencias de dichos productos en el inventario, ya sea incial o final.
"""
```

## Analisis de productos m√°s y menos vendidos.

```{python}
# Encontrar los productos m√°s vendidos
best_selling_products = sales.groupby(['Brand', 'Description']).agg({'SalesQuantity': 'sum'}).sort_values(by='SalesQuantity', ascending=False).iloc[:10]
print(f"Los diez productos m√°s vendidos:\n{best_selling_products}\n")

# Encontrar los productos con menor movimiento
slow_moving_products = sales.groupby(['Brand', 'Description']).agg({'SalesQuantity': 'sum'}).sort_values(by='SalesQuantity', ascending=True)
#.iloc[:10]
print(f"Diez productos de menor movimiento:\n{slow_moving_products}")
```

```{python}
# |  output: true
# Graficar los productos m√°s vendidos
fig = plt.figure(figsize=(8, 6))

sns.barplot(
    data=best_selling_products.reset_index(), 
    x='SalesQuantity', 
    y='Description', 
    hue='Brand', 
    dodge=False, 
    palette='viridis'
)

plt.title("Top 10 Productos M√°s Vendidos")
plt.xlabel("Cantidad Vendida")
plt.ylabel("Producto")
plt.legend(title="Marca", loc='lower right')

# Mostrar el gr√°fico
plt.show()
```

```{python}
# |  output: true

slow_moving_products['Category'] = slow_moving_products['SalesQuantity'].apply(lambda x: 'Se vendieron\n5 unidades\no menos' if x <=5 else 'Se vendieron\nm√°s de\n5 unidades')

summary = slow_moving_products.groupby('Category').size().reset_index(name='Count')

fig, ax = plt.subplots(figsize=(6, 6))
ax.pie(
    summary['Count'], 
    labels=summary['Category'], 
    autopct='%1.0f%%', 
    startangle=90, 
    colors=['skyblue', 'orange'], 
    wedgeprops={'width': 0.7},
    textprops={'fontsize': 14})

total = len(slow_moving_products['Category'])

ax.text(0, 0, f'{total}\nproductos', 
        ha='center', va='center', fontsize=14)

# T√≠tulo del gr√°fico
plt.title('Productos con menor movimiento', fontsize=16)
plt.show()
```

# An√°lisis adicionales 

```{python}
import matplotlib.ticker as ticker

def millions_formatter(x, pos):
    return f'US$ {x / 1e6:.0f} M'

```

```{python}
# Calcular el importe total para beg_inv
beg_inv["ImporteInicial"] = beg_inv["onHand"] * beg_inv["Price"]
importe_total_inicial = beg_inv["ImporteInicial"].sum()

# Calcular el importe total para end_inv
end_inv["ImporteFinal"] = end_inv["onHand"] * end_inv["Price"]
importe_total_final = end_inv["ImporteFinal"].sum()

# Imprimir los resultados
print(f"Importe total del inventario inicial (beg_inv): {importe_total_inicial:.2f}")
print(f"Importe total del inventario final (end_inv): {importe_total_final:.2f}")

# Calcular la diferencia entre el inventario inicial y final
diferencia = importe_total_final - importe_total_inicial
print(f"Diferencia entre inventarios: {diferencia:.2f}")
```

```{python}
# Productos m√°s comprados (con coste total)
best_purchased_products = purchases.groupby(['Brand', 'Description']).agg({
    'Quantity': 'sum',
    'Dollars': 'sum'  # Suponiendo que esta columna contiene el coste total de las compras
}).sort_values(by='Quantity', ascending=False).iloc[:10]

print(f"Los diez productos m√°s comprados (con costo total):\n{best_purchased_products}\n")

# Productos de compra lenta (con coste total)
slow_moving_purchases = purchases.groupby(['Brand', 'Description']).agg({
    'Quantity': 'sum',
    'Dollars': 'sum'
}).sort_values(by='Quantity', ascending=True).iloc[:120]

print(f"Los 100 productos m√°s comprados con menor movimiento (con costo total):\n{slow_moving_purchases}")
```

```{python}
# Productos con una cantidad total de compra exactamente uno

# Agrupar datos para calcular cantidades y costes
low_movement_products = purchases.groupby(['Brand', 'Description']).agg({
    'Quantity': 'sum',
    'Dollars': 'sum'
}).sort_values(by='Quantity', ascending=True)

# Filtrar los productos cuya cantidad total comprada es exactamente uno
products_quantity_one = low_movement_products[low_movement_products['Quantity'] == 1]

# Exportar a un archivo Excel
output_file = "low_movement_products_quantity_one.xlsx"
products_quantity_one.to_excel(output_file, index=True)

print(f"Los productos con una cantidad de compra de exactamente uno se han exportado a:'{output_file}'")
```

```{python}
# Agrupar datos para calcular cantidades y costes
low_movement_products = purchases.groupby(['Brand', 'Description']).agg({
    'Quantity': 'sum',
    'Dollars': 'sum'
}).sort_values(by='Quantity', ascending=True)

# Filtrar los productos cuya cantidad total comprada es exactamente uno
products_quantity_one = low_movement_products[low_movement_products['Quantity'] == 1]

# Contar cu√°ntos productos cumplen la condici√≥n
total_products = products_quantity_one.shape[0]

# Calcular el importe total de estos productos
total_amount = products_quantity_one['Dollars'].sum()

# Mostrar los resultados
print(f"N√∫mero total de productos con una cantidad de compra de exactamente uno: {total_products}")
print(f"Importe total asociado a estos productos: ${total_amount:.2f}")
```

```{python}
# Preparar datos para graficar
products_quantity_one = products_quantity_one.reset_index()  # Restablecer √≠ndice para facilitar el acceso
products_quantity_one = products_quantity_one.sort_values(by='Dollars', ascending=False)  # Ordenar por coste

# Crear el gr√°fico de barras
plt.figure(figsize=(12, 6))
sns.barplot(
    data=products_quantity_one, 
    x='Dollars', 
    y='Description', 
    hue='Brand', 
    dodge=False, 
    palette='coolwarm'
)

# Etiquetas y t√≠tulo
plt.title(f"Productos con Cantidad Comprada Igual a 1\n(Total: {total_products}, Monto Total: ${total_amount:.2f})", fontsize=14, weight='bold', color='tomato')
plt.xlabel("Importe Total en D√≥lares")
plt.ylabel("Descripci√≥n del Producto")
plt.legend(title="Marca", loc='upper right')
plt.grid(axis='x', linestyle='--', alpha=0.6)

# Mostrar el gr√°fico
plt.tight_layout()
plt.show()
"""Podemos notar que el gr√°fico no es lo suficientemente claro, esto se debe a la cantidad de datos disponibles."""
```

```{python}
# Compras totales por mes:

# Asegurar que la columna de fecha est√° en formato datetime
purchases['ReceivingDate'] = pd.to_datetime(purchases['ReceivingDate'])

# Crear una nueva columna con el mes y a√±o
purchases['YearMonth'] = purchases['ReceivingDate'].dt.to_period('M')

# Agrupar por mes y calcular el total de compras
monthly_purchases = purchases.groupby('YearMonth').agg({
    'Quantity': 'sum',
    'Dollars': 'sum'  # Supongamos que 'Dollars' representa el coste total de la compra
}).sort_index()

# Mostrar resultados
print("Compras totales por mes::")
print(monthly_purchases)

# Exportar a un archivo Excel
output_file = "monthly_purchases_summary.xlsx"
monthly_purchases.to_excel(output_file, index=True)

print(f"El resumen de compras mensual se ha exportado a: '{output_file}'")
```

```{python}
# Convertir columnas de fecha a datetime
purchases['ReceivingDate'] = pd.to_datetime(purchases['ReceivingDate'], errors='coerce')
sales['SalesDate'] = pd.to_datetime(sales['SalesDate'], errors='coerce')

# Verificar si alguna conversi√≥n fall√≥
if purchases['ReceivingDate'].isna().any():
    print("Hay valores nulos o no convertibles en 'ReceivingDate'. Verifica los datos.")
if sales['SalesDate'].isna().any():
    print("Hay valores nulos o no convertibles en 'SalesDate'. Verifica los datos.")

# Crear una columna con el mes y a√±o en ambas tablas
purchases['YearMonth'] = purchases['ReceivingDate'].dt.to_period('M')
sales['YearMonth'] = sales['SalesDate'].dt.to_period('M')

# Agrupar por mes y calcular el total de compras y ventas
monthly_purchases = purchases.groupby('YearMonth').agg({
    'Dollars': 'sum'  # Supongamos que 'Dollars' representa el coste total de las compras
}).rename(columns={'Dollars': 'TotalPurchases'})

monthly_sales = sales.groupby('YearMonth').agg({
    'SalesDollars': 'sum'  # Supongamos que 'SalesDollars' representa el ingreso total de las ventas
}).rename(columns={'SalesDollars': 'TotalSales'})

# Encontrar el primer mes com√∫n en ambas tablas
first_month = min(monthly_purchases.index.min(), monthly_sales.index.min())

# Obtener los valores del primer mes
purchases_first_month = monthly_purchases.loc[first_month, 'TotalPurchases'] if first_month in monthly_purchases.index else 0
sales_first_month = monthly_sales.loc[first_month, 'TotalSales'] if first_month in monthly_sales.index else 0

# Calcular la diferencia y el porcentaje
difference = sales_first_month - purchases_first_month
percentage_difference = (difference / purchases_first_month * 100) if purchases_first_month > 0 else None

# Mostrar resultados
print(f"Primer mes: {first_month}")
print(f"Compras totales en el primer mes: ${purchases_first_month:.2f}")
print(f"Ventas totales en el primer mes: ${sales_first_month:.2f}")
print(f"Diferencia (Ventas - Compras): ${difference:.2f}")
if percentage_difference is not None:
    print(f"Diferencia en porcentaje: {percentage_difference:.2f}%")
else:
    print("Diferencia en porcentaje: N/A (Las compras son cero o no est√°n definidas)")
```

```{python}
# |  output: true
# Asegurar que ambos DataFrames tengan un √≠ndice datetime
monthly_purchases.index = monthly_purchases.index.to_timestamp()
monthly_sales.index = monthly_sales.index.to_timestamp()

# Fusionar las tablas para facilitar el graficado
combined_data = monthly_purchases.join(monthly_sales, how='outer').fillna(0)

# Crear el gr√°fico
plt.figure(figsize=(12, 6))
plt.plot(combined_data.index, combined_data['TotalPurchases'], label='Total Purchases', marker='o', color='blue')
plt.plot(combined_data.index, combined_data['TotalSales'], label='Total Sales', marker='o', color='green')

# Resaltar el primer mes
if first_month:
    first_month_date = first_month.to_timestamp()
    plt.axvline(x=first_month_date, color='red', linestyle='--', label='First Month')
    plt.scatter(first_month_date, purchases_first_month, color='blue', zorder=5, label='Purchases (First Month)')
    plt.scatter(first_month_date, sales_first_month, color='green', zorder=5, label='Sales (First Month)')

# Personalizar el gr√°fico
plt.title('Comparaci√≥n Mensual: Compras vs Ventas')
plt.xlabel('Mes')
plt.ylabel('D√≥lares')
plt.legend()
plt.gca().yaxis.set_major_formatter(ticker.FuncFormatter(millions_formatter))
plt.grid(alpha=0.3)
plt.xticks(rotation=45)
plt.tight_layout()

# Mostrar el gr√°fico
plt.show()
```

El gr√°fico muestra que las compras son mayores que las ventas durante varios meses consecutivos, esto podr√≠a significar que:

- Se est√° adquiriendo m√°s inventario del necesario.  
- Podr√≠a haber un problema de rotaci√≥n de inventarios, lo que conllevar√≠a a costos de almacenamiento elevados.


Si las ventas son mayores que las compras en la mayor√≠a de los meses:

- Esto podr√≠a ser positivo, mostrando una buena utilizaci√≥n del inventario, pero es importante monitorear para evitar quedarse sin existencias.


```{python}
# Calcular el margen
margin = 0.45

# Agrupar las compras por mes y calcular el total
annual_purchases = purchases.groupby('YearMonth').agg({
    'Dollars': 'sum'  # Supongamos que 'Dollars' representa el coste total de las compras
}).rename(columns={'Dollars': 'TotalPurchases'})

# Calcular las ventas estimadas para todo el a√±o con el margen aplicado
annual_purchases['EstimatedSales'] = annual_purchases['TotalPurchases'] * (1 + margin)

# Calcular el total anual de compras y ventas estimadas
total_purchases = annual_purchases['TotalPurchases'].sum()
total_estimated_sales = annual_purchases['EstimatedSales'].sum()

# Mostrar los resultados
print(f"Compras totales del a√±o: ${total_purchases:.2f}")
print(f"Ventas totales estimadas para el a√±o (margen del 45%): ${total_estimated_sales:.2f}")

# Mostrar el desglose mensual (opcional)
print("\nDesglose mensual::")
print(annual_purchases)
```

```{python}
# Calcular la diferencia entre las ventas estimadas y las compras totales
difference = total_estimated_sales - total_purchases

# Calcular el porcentaje de diferencia
percentage_difference = (difference / total_purchases) * 100 if total_purchases > 0 else None

# Mostrar los resultados
print(f"Compras totales del a√±o: ${total_purchases:.2f}")
print(f"Ventas totales estimadas para el a√±o (margen del 45%): ${total_estimated_sales:.2f}")
print(f"Diferencia (Ventas - Compras): ${difference:.2f}")
if percentage_difference is not None:
    print(f"Diferencia en porcentaje: {percentage_difference:.2f}%")
else:
    print("Diferencia en porcentaje: N/A (Las compras son cero o no est√°n definidas)")
```

```{python}
# |  output: true
# Crear un DataFrame para las m√©tricas clave
data = {
    'Categor√≠a': ['Compras Totales', 'Ventas Estimadas', 'Diferencia'],
    'Monto': [total_purchases, total_estimated_sales, difference]
}
metrics_df = pd.DataFrame(data)

# Configuraci√≥n del gr√°fico
plt.figure(figsize=(10, 6))
ax = sns.barplot(
    data=metrics_df, 
    x='Categor√≠a', 
    y='Monto', 
    hue='Categor√≠a',  # Usamos 'Categor√≠a' como variable para el color
    dodge=False, 
    palette=['skyblue', 'limegreen', 'tomato'],
    legend=False  # Evitamos agregar una leyenda extra
)
ax.yaxis.set_major_formatter(ticker.FuncFormatter(millions_formatter))
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
# Etiquetas y personalizaci√≥n
plt.title("Comparaci√≥n: Compras Totales vs Ventas Estimadas vs Diferencia", fontsize=14, weight='bold', color='tomato')
plt.ylabel("Monto en Millones de D√≥lares")
plt.xlabel("Categor√≠as")
plt.grid(axis='y', linestyle='--', alpha=0.6)

# Agregar valores sobre las barras
for i, value in enumerate(metrics_df['Monto']):
    plt.text(
        i,
        value + (max(metrics_df['Monto']) * 0.02),
        millions_formatter(value, None),
        ha='center',
        va='bottom',
        fontsize=11,
        fontweight='bold',
        color='navy'
    )
# Mostrar el gr√°fico
plt.tight_layout()
plt.show()
```

![](figures/powerbi_negativos.jpeg)

Mediante el dashboard de PowerBI se evidencia el problema del exceso de botellas y su implicancia en las p√©rdidas de la empresa.
